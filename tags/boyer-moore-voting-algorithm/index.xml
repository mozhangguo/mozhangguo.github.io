<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Boyer-Moore Voting Algorithm on Mozhang Guo Blog</title>
    <link>https://mozhangguo.github.io/tags/boyer-moore-voting-algorithm/</link>
    <description>Recent content in Boyer-Moore Voting Algorithm on Mozhang Guo Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <managingEditor>me@example.com (Mozhang Guo)</managingEditor>
    <webMaster>me@example.com (Mozhang Guo)</webMaster>
    <lastBuildDate>Sun, 18 Feb 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://mozhangguo.github.io/tags/boyer-moore-voting-algorithm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>LeetCode 169. Majority Element</title>
      <link>https://mozhangguo.github.io/post/notes/leetcode169/</link>
      <pubDate>Sun, 18 Feb 2024 00:00:00 +0000</pubDate><author>me@example.com (Mozhang Guo)</author>
      <guid>https://mozhangguo.github.io/post/notes/leetcode169/</guid>
      <description>This problem asked us to return the majority elements that appears more than [n/2] times. The problem itself is not that hard to complete with hash table or sorting algorithms. The intuition behind this problem can be understood as to find the frequency of each element in the given array and return the most frequent element. The table below summarize the space and time complexity of these algorirthms.&#xA;Algorithm Time Complexity Space Complexity Hash Table O(N) O(N) Sorting O(N) O(N) However, the follow-up question asked us to solve the problem in linear time O(n) and constant space O(1).</description>
    </item>
  </channel>
</rss>
